;1
(define (make-clock h m)
  (let ((minutes (+ (* h 60) m)))
    (define (tick)
      (if (= minutes 1439)
          (set! minutes 0)
          (set! minutes (+ minutes 1))))
    (define (time)
      (cond ((= minutes 1440) (string-append (number->string (- (/ minutes 60) 12)) ":" "00 AM" "\n"))
            ((= minutes 720) (string-append (number->string (/ minutes 60)) ":" "00 PM" "\n"))
            ((< minutes 720) (string-append (if (= (floor (/ minutes 60)) 0)
                                                (string-append "12")
                                                (string-append (number->string (floor (/ minutes 60)))))
                                            ":"
                                            (if (< (* (- (/ minutes 60) (floor (/ minutes 60))) 60) 10)
                                                (string-append "0" (number->string (* (- (/ minutes 60) (floor (/ minutes 60))) 60)) " AM")
                                                (string-append (number->string (* (- (/ minutes 60) (floor (/ minutes 60))) 60)) " AM")) "\n"))
            ((> minutes 720) (string-append (if (= (floor (/ minutes 60)) 12)
                                                (string-append "12")
                                                (string-append (number->string (- (floor (/ minutes 60)) 12))))
                                            ":"
                                            (if (< (* (- (/ minutes 60) (floor (/ minutes 60))) 60) 10)
                                                (string-append "0" (number->string (* (- (/ minutes 60) (floor (/ minutes 60))) 60)) " PM")
                                                (string-append (number->string (* (- (/ minutes 60) (floor (/ minutes 60))) 60)) " PM")) "\n"))))
    (define (military)
      (if (< minutes 720)
          (string-append "0" (number->string (floor (/ minutes 60))) ":"
                         (if (< (* (- (/ minutes 60) (floor (/ minutes 60))) 60) 10)
                             (string-append "0" (number->string (* (- (/ minutes 60) (floor (/ minutes 60))) 60)))
                             (string-append (number->string (* (- (/ minutes 60) (floor (/ minutes 60))) 60)))) "\n")
          (string-append (number->string (floor (/ minutes 60))) ":"
                         (if (< (* (- (/ minutes 60) (floor (/ minutes 60))) 60) 10)
                             (string-append "0" (number->string (* (- (/ minutes 60) (floor (/ minutes 60))) 60)))
                             (string-append (number->string (* (- (/ minutes 60) (floor (/ minutes 60))) 60)))) "\n")))
    (lambda (method)
      (cond ((eq? method 'tick) tick)
            ((eq? method 'time) time)
            ((eq? method 'military) military)))))

(define my-clock (make-clock 23 59))
((my-clock 'tick))
((my-clock 'tick))
((my-clock 'tick))
((my-clock 'time))

;2
(define (make-stack)
  (let ((s '()))
    (define (empty?)
      (if (null? s)
          #t
          #f))
    (define (push x)
      (set! s (cons x s)))
    (define (pop)
      (let ((top (car s)))
        (begin (set! s (cdr s))
               top)))
    (define (top) (car s))
    (define (dispatcher method)
      (cond ((eq? method 'empty?) empty?)
            ((eq? method 'push) push)
            ((eq? method 'pop) pop)
            ((eq? method 'top) top)))
    dispatcher))

;3
(define (eval-postfix p)
  (let ((expression '()))
    (define (pop)
      (let ((top (car expression)))
        (begin (set! expression (cdr expression))
               top)))
    (define (operator o)
      (let ((b (pop))
            (a (pop)))
        (cond ((eq? o #\+) (set! expression (cons (+ a b) expression)))
              ((eq? o #\-) (set! expression (cons (- a b) expression)))
              ((eq? o #\*) (set! expression (cons (* a b) expression)))
              ((eq? o #\/) (set! expression (cons (/ a b) expression)))
              ((eq? o #\^) (set! expression (cons (expt a b) expression))))))
    (define (helper l)
      (cond ((null? l)
             (car expression))
            ((number? (car l))
             (begin (set! expression (cons (car l) expression))
                    (helper (cdr l))))
            (else
             (begin (operator (car l))
                    (helper (cdr l))))))
    (helper p)))

;4
(define (value T) (car T))
(define (left T) (cadr T))
(define (right T) (caddr T))

(define (dfs T)
  (let ((output '()))
    (define stack (make-stack))
    ((stack 'push) T)
    (define (dfs-help)
      (if (not ((stack 'empty?)))
          (let ((tree ((stack 'pop))))
            (begin (set! output (cons (value tree) output))
                   (if (not (null? (right tree)))
                       ((stack 'push) (right tree)))
                   (if (not (null? (left tree)))
                       ((stack 'push) (left tree)))
                   (dfs-help)))))
    (dfs-help)
    (reverse output)))

;5
(define (enqueue x Q)
  (if (null? Q)
      (list x)
      (cons (car Q) (enqueue x (cdr Q)))))
(define (dequeue Q) (cdr Q))
(define (front Q) (car Q))
(define (empty? Q) (null? Q))

(define (bfs T)
  (let ((output '())
        (queue '()))
    (set! queue (cons T queue))
    (define (bfs-help)
      (if (not (empty? queue))
          (let ((tree (front queue)))
            (begin (set! output (cons (value tree) output))
                   (set! queue (dequeue queue))
                   (if (not (null? (left tree)))
                       (set! queue (enqueue (left tree) queue)))
                   (if (not (null? (right tree)))
                       (set! queue (enqueue (right tree) queue)))
                   (bfs-help)))))
    (bfs-help)
    (reverse output)))



